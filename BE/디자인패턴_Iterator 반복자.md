# 디자인패턴_ Iterator 반복자

출처 URL @Dongho Sim님 [바로가기](https://dhsim86.github.io/programming/2019/11/16/design_patterns_15-post.html)





<br><br>

반복자(Iterator) 패턴은 **내부 표현부를 노출하지 않고, 어떤 집합 객체에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공**한다.

리스트와 같은 어느 원소의 집합을 나타내는 객체들은 **내부 표현 구조를 노출하지 않고 자신의 원소를 접근할 수 있는 방법**을 제공하는 것이 좋다. 또한 이 객체가 지원하는 방법과 다른 방법으로 원소를 순회할 때도 있다. 순회 방법이 바뀐다고 해서 이 객체에 대한 인터페이스를 변경하고 싶지는 않을 수 있다. 또한 **동일한 집합에 대해서도 하나 이상의 순회 방법**을 정의하고 싶을 때도 있다.

이런 문제를 해결하는 데 사용하는 것이 바로 반복자 패턴이다. 이 패턴은 **집합을 나타내는 객체에 접근하여 새로운 내용을 삽입, 삭제하거나 순회하는 내용을 반복자 객체에 정의하는 것이다.** 반복자를 나타내는 Iterator 클래스는 원소들에 접근하는데 필요한 인터페이스를 제공하는데, 현재 원소가 무엇인지 관리하고 이미 방문한 원소들이 무엇인지 알고 있다.

![00.png](https://dhsim86.github.io/static/assets/img/blog/programming/2019-11-16-design_patterns_15/00.png)

위와 같이 ListIterator 반복자 객체는 바라보고 있는 List 객체의 원소에 접근할 수 있는 연산을 지원한다. 순회하는 메커니즘을 클래스 List에서 분리하면, **List의 인터페이스를 변경하지 않고도 다양한 순회 알고리즘을 구현할 수 있다.** 만약 어떤 순회 알고리즘이 필요하다면 이를 지원하는 반복자 객체를 정의하여 구현하면 된다.

![01.png](https://dhsim86.github.io/static/assets/img/blog/programming/2019-11-16-design_patterns_15/01.png)

다양한 구조를 가지는 집합을 나타내는 객체(Aggregate)가 있을 때, 필요한 공통의 인터페이스는 Aggegate 추상 클래스에 정의하고, 이를 상속받아 다양한 집합 구조를 표현하는 집합 클래스를 정의한다.

마찬가지로 집합의 원소에 접근하는데 필요한 공통의 인터페이스를 제공하는 Iterator 클래스를 정의하고 서로 다른 구조를 가지는 Aggregate 서브 클래스마다 구체적인 접근 기법을 제공하는 Iterator의 서브 클래스를 정의하도록 한다.

사용자는 추상 클래스인 Aggregate 및 Iterator들만 사용하도록 하면 실제 구체적인 집합 객체나 반복자에 의존하지 않아도 된다.

> Iterator 객체는 집합 객체에 정의된 팩토리 메서드를 통해 생성한다. 팩토리 메서드를 통해 사용 중인 집합 객체에 대해 실제로 필요한 Iterator 객체를 얻을 수 있다.

반복자 패턴을 통해 객체 내부 표현 방식을 모르고도 집합 객체의 원소에 접근할 수 있게 되며, 서로 다른 집합 객체에 대해서도 동일한 인터페이스로 순회할 수 있다. 또한 반복자 객체에서 순회를 위한 연산이 정의되므로, 집합 객체의 인터페이스를 단순화시킬 수 있다.